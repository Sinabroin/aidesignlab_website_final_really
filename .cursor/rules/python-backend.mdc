---
description: Python backend standards - type hints, Pydantic models, SQLModel patterns
globs: apps/api/**/*.py
alwaysApply: false
---

# Python Backend Standards

## Strict Type Hints

**ALL functions** must have type hints for parameters and return types:

```python
# ❌ BAD
def get_user(user_id):
    return db.query(User).filter(User.id == user_id).first()

# ✅ GOOD
from typing import Optional
from sqlmodel import Session, select

def get_user(session: Session, user_id: int) -> Optional[User]:
    """Retrieve a user by ID."""
    statement = select(User).where(User.id == user_id)
    return session.exec(statement).first()
```

## Pydantic Models for Data Structures

Use **Pydantic models** for ALL data structures:
- Request/Response schemas
- Configuration (via `pydantic-settings`)
- Data validation

**Example**:
```python
from pydantic import BaseModel, Field

class UserCreate(BaseModel):
    """Schema for creating a new user."""
    email: str = Field(..., description="User email address")
    name: str = Field(..., min_length=1, max_length=100)
    age: Optional[int] = Field(None, ge=0, le=150)

class UserResponse(BaseModel):
    """Schema for user response."""
    id: int
    email: str
    name: str
    created_at: datetime
```

## SQLModel Patterns

- Use `SQLModel` for database models (combines Pydantic + SQLAlchemy)
- Use `SessionDep` pattern for dependency injection
- Define relationships with proper typing

**Example**:
```python
from sqlmodel import SQLModel, Field, Relationship
from typing import Optional, List

class User(SQLModel, table=True):
    """User database model."""
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(unique=True, index=True)
    name: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # Relationships
    posts: List["Post"] = Relationship(back_populates="author")

class Post(SQLModel, table=True):
    """Post database model."""
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str
    content: str
    author_id: int = Field(foreign_key="user.id")
    
    author: User = Relationship(back_populates="posts")
```

## FastAPI Router Patterns

- Use `APIRouter` for modularity
- Group related endpoints in separate router files
- Use dependency injection for database sessions

**Example**:
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    session: Session = Depends(get_session),
) -> UserResponse:
    """Get user by ID."""
    user = get_user_by_id(session, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return UserResponse.model_validate(user)
```

## Naming Conventions

- **snake_case** for functions/variables: `get_user_data()`
- **PascalCase** for Classes/Models: `User`, `UserResponse`
- **UPPER_CASE** for constants: `MAX_RETRIES = 3`
