# Project Context
- **Architecture**: Monorepo
- **Frontend**: `apps/web` (Next.js App Router, TypeScript, TailwindCSS)
- **Backend**: `apps/api` (FastAPI, Python 3.12+, SQLModel, Pydantic, uv package manager)
- **AI Model**: Claude Code (via Cursor)

# Core Philosophy
"Vibe Coding" means writing robust, production-ready code swiftly. We value **Strict Typing**, **Modularity**, and **Stability**.

<critical_rules>
1. **The 30-Line Rule**:
   - STRICTLY enforce a limit of **30 lines of code** per function or component body.
   - If a function grows beyond 30 lines, YOU MUST refactor it into smaller, named helper functions or custom hooks immediately.
   - Do not ask for permission to refactor; just do it.

2. **One-Line File Header**:
   - EVERY new file must start with a comment explaining its purpose.
   - Python: `# This file handles [purpose]...`
   - TS/TSX: `/** This component displays [purpose]... */`

3. **Strict Typing (No 'Any')**:
   - **Python**: Use Pydantic models for ALL data structures. Use Type Hints for ALL function arguments and return values.
   - **TypeScript**: No `any`. Define interfaces/types for all props and API responses.

4. **Safety & Error Handling**:
   - Assume external services (DB, API) will fail. Wrap logic in try/except (Python) or try/catch (TS).
   - Python: Raise HTTPExceptions explicitly.
   - Frontend: Show UI fallbacks (Error Boundaries) or toast notifications on error.
</critical_rules>

<tech_stack_rules>

  <backend_python>
    - **Package Manager**: Use `uv` strictly. (e.g., `uv add fastapi`, `uv run main.py`).
    - **FastAPI**: Use `APIRouter` for modularity.
    - **SQLModel**: Use `SessionDep` pattern for DB injection.
    - **Pydantic**: Use `Field` for validation and schema documentation.
    - **Naming**: snake_case for functions/variables, PascalCase for Classes/Models.
  </backend_python>

  <frontend_typescript>
    - **Structure**: Use Functional Components (`const Component = () => {}`).
    - **State**: Use `zustand` or `React Context` for global state if needed.
    - **Data Fetching**: Use `tanstack-query` (react-query) for API calls if applicable, or server actions.
    - **Naming**: camelCase for functions/variables, PascalCase for Components.
  </frontend_typescript>

</tech_stack_rules>

<planning_phase>
Before writing any code, specifically for complex tasks:
1. **Analyze**: briefly list the necessary changes.
2. **Structure**: Plan the function splits to ensure the <30 lines rule.
3. **Safety Check**: Identify potential error points (null values, API failures).
4. **Execute**: Write the code.
</planning_phase>

<format_example>
# Python Example
# Service for calculating user tax rates
def calculate_tax(income: float) -> float:
    """Calculates tax based on income brackets."""
    try:
        if income < 0:
            raise ValueError("Income cannot be negative")
        return _apply_tax_rules(income)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

# TypeScript Example
/** Component for displaying user profile information */
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

export const UserProfile: React.FC<UserProfileProps> = ({ userId, onUpdate }) => {
  const [user, setUser] = useState<User | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUser(userId).catch((err) => {
      setError(err.message);
    });
  }, [userId]);

  if (error) return <ErrorFallback message={error} />;
  if (!user) return <LoadingSpinner />;
  return <ProfileCard user={user} />;
};
</format_example>
